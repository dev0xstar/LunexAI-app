(self.webpackChunk_N_E = self.webpackChunk_N_E || []).push([
  [322],
  {
    7779: function (e, t, r) {
      "use strict";
      r.r(t),
        r.d(t, {
          BaseContract: function () {
            return a.VZ;
          },
          BigNumber: function () {
            return c.O$;
          },
          Contract: function () {
            return a.CH;
          },
          ContractFactory: function () {
            return a.lV;
          },
          FixedNumber: function () {
            return u.xs;
          },
          Signer: function () {
            return l.E;
          },
          VoidSigner: function () {
            return l.b;
          },
          Wallet: function () {
            return p.Wallet;
          },
          Wordlist: function () {
            return ed.D;
          },
          constants: function () {
            return n;
          },
          errors: function () {
            return P.ErrorCode;
          },
          ethers: function () {
            return s;
          },
          getDefaultProvider: function () {
            return el;
          },
          logger: function () {
            return eD;
          },
          providers: function () {
            return o;
          },
          utils: function () {
            return i;
          },
          version: function () {
            return eK;
          },
          wordlists: function () {
            return ep.E;
          },
        });
      var n = {};
      r.r(n),
        r.d(n, {
          AddressZero: function () {
            return d.d;
          },
          EtherSymbol: function () {
            return g;
          },
          HashZero: function () {
            return f.R;
          },
          MaxInt256: function () {
            return h.PS;
          },
          MaxUint256: function () {
            return h.Bz;
          },
          MinInt256: function () {
            return h.$B;
          },
          NegativeOne: function () {
            return h.tL;
          },
          One: function () {
            return h.fh;
          },
          Two: function () {
            return h.Py;
          },
          WeiPerEther: function () {
            return h.Ce;
          },
          Zero: function () {
            return h._Y;
          },
        });
      var o = {};
      r.r(o),
        r.d(o, {
          AlchemyProvider: function () {
            return C;
          },
          AlchemyWebSocketProvider: function () {
            return A;
          },
          AnkrProvider: function () {
            return U;
          },
          BaseProvider: function () {
            return b.Zk;
          },
          CloudflareProvider: function () {
            return K;
          },
          EtherscanProvider: function () {
            return Z;
          },
          FallbackProvider: function () {
            return z.H;
          },
          Formatter: function () {
            return w.Mb;
          },
          InfuraProvider: function () {
            return et;
          },
          InfuraWebSocketProvider: function () {
            return ee;
          },
          IpcProvider: function () {
            return Q;
          },
          JsonRpcBatchProvider: function () {
            return er;
          },
          JsonRpcProvider: function () {
            return v.r;
          },
          JsonRpcSigner: function () {
            return v.C;
          },
          NodesmithProvider: function () {
            return eo;
          },
          PocketProvider: function () {
            return ea;
          },
          Provider: function () {
            return m.zt;
          },
          Resolver: function () {
            return b.H2;
          },
          StaticJsonRpcProvider: function () {
            return N.c;
          },
          UrlJsonRpcProvider: function () {
            return N.l;
          },
          Web3Provider: function () {
            return ec.Q;
          },
          WebSocketProvider: function () {
            return I;
          },
          getDefaultProvider: function () {
            return el;
          },
          getNetwork: function () {
            return y.H;
          },
          isCommunityResourcable: function () {
            return w.Ed;
          },
          isCommunityResource: function () {
            return w.Gp;
          },
          showThrottleMessage: function () {
            return w.vh;
          },
        });
      var i = {};
      r.r(i),
        r.d(i, {
          AbiCoder: function () {
            return eh.R;
          },
          ConstructorFragment: function () {
            return ef.Xg;
          },
          ErrorFragment: function () {
            return ef.IC;
          },
          EventFragment: function () {
            return ef.QV;
          },
          FormatTypes: function () {
            return ef.pc;
          },
          Fragment: function () {
            return ef.HY;
          },
          FunctionFragment: function () {
            return ef.YW;
          },
          HDNode: function () {
            return eS.HDNode;
          },
          Indexed: function () {
            return em.Hk;
          },
          Interface: function () {
            return em.vU;
          },
          LogDescription: function () {
            return em.CC;
          },
          Logger: function () {
            return P.Logger;
          },
          ParamType: function () {
            return ef._R;
          },
          RLP: function () {
            return eO;
          },
          SigningKey: function () {
            return eA.SigningKey;
          },
          SupportedAlgorithm: function () {
            return eB.p;
          },
          TransactionDescription: function () {
            return em.vk;
          },
          TransactionTypes: function () {
            return H.TransactionTypes;
          },
          UnicodeNormalizationForm: function () {
            return eL.Uj;
          },
          Utf8ErrorFuncs: function () {
            return eL.te;
          },
          Utf8ErrorReason: function () {
            return eL.Uw;
          },
          _TypedDataEncoder: function () {
            return eE.E;
          },
          _fetchData: function () {
            return F._fetchData;
          },
          _toEscapedUtf8String: function () {
            return eL.U$;
          },
          accessListify: function () {
            return H.accessListify;
          },
          arrayify: function () {
            return D.arrayify;
          },
          base58: function () {
            return ek.Base58;
          },
          base64: function () {
            return eb;
          },
          checkProperties: function () {
            return k.checkProperties;
          },
          checkResultErrors: function () {
            return eg.BR;
          },
          commify: function () {
            return eU.commify;
          },
          computeAddress: function () {
            return H.computeAddress;
          },
          computeHmac: function () {
            return ex.Gy;
          },
          computePublicKey: function () {
            return eA.computePublicKey;
          },
          concat: function () {
            return D.concat;
          },
          deepCopy: function () {
            return k.deepCopy;
          },
          defaultAbiCoder: function () {
            return eh.$;
          },
          defaultPath: function () {
            return eS.defaultPath;
          },
          defineReadOnly: function () {
            return k.defineReadOnly;
          },
          dnsEncode: function () {
            return ew.Kn;
          },
          entropyToMnemonic: function () {
            return eS.entropyToMnemonic;
          },
          fetchJson: function () {
            return F.fetchJson;
          },
          formatBytes32String: function () {
            return ej.s;
          },
          formatEther: function () {
            return eU.formatEther;
          },
          formatUnits: function () {
            return eU.formatUnits;
          },
          getAccountPath: function () {
            return eS.getAccountPath;
          },
          getAddress: function () {
            return ey.getAddress;
          },
          getContractAddress: function () {
            return ey.getContractAddress;
          },
          getCreate2Address: function () {
            return ey.getCreate2Address;
          },
          getIcapAddress: function () {
            return ey.getIcapAddress;
          },
          getJsonWalletAddress: function () {
            return e_.Rb;
          },
          getStatic: function () {
            return k.getStatic;
          },
          hashMessage: function () {
            return ev.r;
          },
          hexConcat: function () {
            return D.hexConcat;
          },
          hexDataLength: function () {
            return D.hexDataLength;
          },
          hexDataSlice: function () {
            return D.hexDataSlice;
          },
          hexStripZeros: function () {
            return D.hexStripZeros;
          },
          hexValue: function () {
            return D.hexValue;
          },
          hexZeroPad: function () {
            return D.hexZeroPad;
          },
          hexlify: function () {
            return D.hexlify;
          },
          id: function () {
            return eP.id;
          },
          isAddress: function () {
            return ey.isAddress;
          },
          isBytes: function () {
            return D.isBytes;
          },
          isBytesLike: function () {
            return D.isBytesLike;
          },
          isHexString: function () {
            return D.isHexString;
          },
          isValidMnemonic: function () {
            return eS.isValidMnemonic;
          },
          isValidName: function () {
            return ew.r1;
          },
          joinSignature: function () {
            return D.joinSignature;
          },
          keccak256: function () {
            return eR.keccak256;
          },
          mnemonicToEntropy: function () {
            return eS.mnemonicToEntropy;
          },
          mnemonicToSeed: function () {
            return eS.mnemonicToSeed;
          },
          namehash: function () {
            return ew.VM;
          },
          nameprep: function () {
            return eC.Ll;
          },
          parseBytes32String: function () {
            return ej.F;
          },
          parseEther: function () {
            return eU.parseEther;
          },
          parseTransaction: function () {
            return H.parse;
          },
          parseUnits: function () {
            return eU.parseUnits;
          },
          poll: function () {
            return F.poll;
          },
          randomBytes: function () {
            return eN.O;
          },
          recoverAddress: function () {
            return H.recoverAddress;
          },
          recoverPublicKey: function () {
            return eA.recoverPublicKey;
          },
          resolveProperties: function () {
            return k.resolveProperties;
          },
          ripemd160: function () {
            return ex.bP;
          },
          serializeTransaction: function () {
            return H.serialize;
          },
          sha256: function () {
            return ex.JQ;
          },
          sha512: function () {
            return ex.o;
          },
          shallowCopy: function () {
            return k.shallowCopy;
          },
          shuffled: function () {
            return eT.y;
          },
          solidityKeccak256: function () {
            return eI.keccak256;
          },
          solidityPack: function () {
            return eI.pack;
          },
          soliditySha256: function () {
            return eI.sha256;
          },
          splitSignature: function () {
            return D.splitSignature;
          },
          stripZeros: function () {
            return D.stripZeros;
          },
          toUtf8Bytes: function () {
            return eL.Y0;
          },
          toUtf8CodePoints: function () {
            return eL.XL;
          },
          toUtf8String: function () {
            return eL.ZN;
          },
          verifyMessage: function () {
            return p.verifyMessage;
          },
          verifyTypedData: function () {
            return p.verifyTypedData;
          },
          zeroPad: function () {
            return D.zeroPad;
          },
        });
      var s = {};
      r.r(s),
        r.d(s, {
          BaseContract: function () {
            return a.VZ;
          },
          BigNumber: function () {
            return c.O$;
          },
          Contract: function () {
            return a.CH;
          },
          ContractFactory: function () {
            return a.lV;
          },
          FixedNumber: function () {
            return u.xs;
          },
          Signer: function () {
            return l.E;
          },
          VoidSigner: function () {
            return l.b;
          },
          Wallet: function () {
            return p.Wallet;
          },
          Wordlist: function () {
            return ed.D;
          },
          constants: function () {
            return n;
          },
          errors: function () {
            return P.ErrorCode;
          },
          getDefaultProvider: function () {
            return el;
          },
          logger: function () {
            return eD;
          },
          providers: function () {
            return o;
          },
          utils: function () {
            return i;
          },
          version: function () {
            return eK;
          },
          wordlists: function () {
            return ep.E;
          },
        });
      var a = r(4146),
        c = r(2593),
        u = r(335),
        l = r(8088),
        p = r(9911),
        d = r(9279),
        h = r(1046),
        f = r(7218);
      let g = "Îž";
      var m = r(1556),
        y = r(5710),
        b = r(7013),
        k = r(6881),
        w = r(32),
        v = r(2169),
        P = r(1581),
        E = r(4216);
      let S = null;
      try {
        if (((S = WebSocket), null == S)) throw Error("inject please");
      } catch (t) {
        let e = new P.Logger(E.i);
        S = function () {
          e.throwError(
            "WebSockets not supported in this environment",
            P.Logger.errors.UNSUPPORTED_OPERATION,
            { operation: "new WebSocket()" }
          );
        };
      }
      var _ = function (e, t, r, n) {
        return new (r || (r = Promise))(function (o, i) {
          function s(e) {
            try {
              c(n.next(e));
            } catch (e) {
              i(e);
            }
          }
          function a(e) {
            try {
              c(n.throw(e));
            } catch (e) {
              i(e);
            }
          }
          function c(e) {
            var t;
            e.done
              ? o(e.value)
              : ((t = e.value) instanceof r
                  ? t
                  : new r(function (e) {
                      e(t);
                    })
                ).then(s, a);
          }
          c((n = n.apply(e, t || [])).next());
        });
      };
      let R = new P.Logger(E.i),
        x = 1;
      class I extends v.r {
        constructor(e, t) {
          "any" === t &&
            R.throwError(
              "WebSocketProvider does not support 'any' network yet",
              P.Logger.errors.UNSUPPORTED_OPERATION,
              { operation: "network:any" }
            ),
            "string" == typeof e ? super(e, t) : super("_websocket", t),
            (this._pollingInterval = -1),
            (this._wsReady = !1),
            "string" == typeof e
              ? (0, k.defineReadOnly)(
                  this,
                  "_websocket",
                  new S(this.connection.url)
                )
              : (0, k.defineReadOnly)(this, "_websocket", e),
            (0, k.defineReadOnly)(this, "_requests", {}),
            (0, k.defineReadOnly)(this, "_subs", {}),
            (0, k.defineReadOnly)(this, "_subIds", {}),
            (0, k.defineReadOnly)(
              this,
              "_detectNetwork",
              super.detectNetwork()
            ),
            (this.websocket.onopen = () => {
              (this._wsReady = !0),
                Object.keys(this._requests).forEach((e) => {
                  this.websocket.send(this._requests[e].payload);
                });
            }),
            (this.websocket.onmessage = (e) => {
              let t = e.data,
                r = JSON.parse(t);
              if (null != r.id) {
                let e = String(r.id),
                  n = this._requests[e];
                if ((delete this._requests[e], void 0 !== r.result))
                  n.callback(null, r.result),
                    this.emit("debug", {
                      action: "response",
                      request: JSON.parse(n.payload),
                      response: r.result,
                      provider: this,
                    });
                else {
                  let e = null;
                  r.error
                    ? ((e = Error(r.error.message || "unknown error")),
                      (0, k.defineReadOnly)(e, "code", r.error.code || null),
                      (0, k.defineReadOnly)(e, "response", t))
                    : (e = Error("unknown error")),
                    n.callback(e, void 0),
                    this.emit("debug", {
                      action: "response",
                      error: e,
                      request: JSON.parse(n.payload),
                      provider: this,
                    });
                }
              } else if ("eth_subscription" === r.method) {
                let e = this._subs[r.params.subscription];
                e && e.processFunc(r.params.result);
              } else console.warn("this should not happen");
            });
          let r = setInterval(() => {
            this.emit("poll");
          }, 1e3);
          r.unref && r.unref();
        }
        get websocket() {
          return this._websocket;
        }
        detectNetwork() {
          return this._detectNetwork;
        }
        get pollingInterval() {
          return 0;
        }
        resetEventsBlock(e) {
          R.throwError(
            "cannot reset events block on WebSocketProvider",
            P.Logger.errors.UNSUPPORTED_OPERATION,
            { operation: "resetEventBlock" }
          );
        }
        set pollingInterval(e) {
          R.throwError(
            "cannot set polling interval on WebSocketProvider",
            P.Logger.errors.UNSUPPORTED_OPERATION,
            { operation: "setPollingInterval" }
          );
        }
        poll() {
          return _(this, void 0, void 0, function* () {
            return null;
          });
        }
        set polling(e) {
          e &&
            R.throwError(
              "cannot set polling on WebSocketProvider",
              P.Logger.errors.UNSUPPORTED_OPERATION,
              { operation: "setPolling" }
            );
        }
        send(e, t) {
          let r = x++;
          return new Promise((n, o) => {
            let i = JSON.stringify({
              method: e,
              params: t,
              id: r,
              jsonrpc: "2.0",
            });
            this.emit("debug", {
              action: "request",
              request: JSON.parse(i),
              provider: this,
            }),
              (this._requests[String(r)] = {
                callback: function (e, t) {
                  return e ? o(e) : n(t);
                },
                payload: i,
              }),
              this._wsReady && this.websocket.send(i);
          });
        }
        static defaultUrl() {
          return "ws://localhost:8546";
        }
        _subscribe(e, t, r) {
          return _(this, void 0, void 0, function* () {
            let n = this._subIds[e];
            null == n &&
              ((n = Promise.all(t).then((e) => this.send("eth_subscribe", e))),
              (this._subIds[e] = n));
            let o = yield n;
            this._subs[o] = { tag: e, processFunc: r };
          });
        }
        _startEvent(e) {
          switch (e.type) {
            case "block":
              this._subscribe("block", ["newHeads"], (e) => {
                let t = c.O$.from(e.number).toNumber();
                (this._emitted.block = t), this.emit("block", t);
              });
              break;
            case "pending":
              this._subscribe("pending", ["newPendingTransactions"], (e) => {
                this.emit("pending", e);
              });
              break;
            case "filter":
              this._subscribe(
                e.tag,
                ["logs", this._getFilter(e.filter)],
                (t) => {
                  null == t.removed && (t.removed = !1),
                    this.emit(e.filter, this.formatter.filterLog(t));
                }
              );
              break;
            case "tx": {
              let t = (e) => {
                let t = e.hash;
                this.getTransactionReceipt(t).then((e) => {
                  e && this.emit(t, e);
                });
              };
              t(e),
                this._subscribe("tx", ["newHeads"], (e) => {
                  this._events.filter((e) => "tx" === e.type).forEach(t);
                });
              break;
            }
            case "debug":
            case "poll":
            case "willPoll":
            case "didPoll":
            case "error":
              break;
            default:
              console.log("unhandled:", e);
          }
        }
        _stopEvent(e) {
          let t = e.tag;
          if ("tx" === e.type) {
            if (this._events.filter((e) => "tx" === e.type).length) return;
            t = "tx";
          } else if (this.listenerCount(e.event)) return;
          let r = this._subIds[t];
          r &&
            (delete this._subIds[t],
            r.then((e) => {
              this._subs[e] &&
                (delete this._subs[e], this.send("eth_unsubscribe", [e]));
            }));
        }
        destroy() {
          return _(this, void 0, void 0, function* () {
            this.websocket.readyState === S.CONNECTING &&
              (yield new Promise((e) => {
                (this.websocket.onopen = function () {
                  e(!0);
                }),
                  (this.websocket.onerror = function () {
                    e(!1);
                  });
              })),
              this.websocket.close(1e3);
          });
        }
      }
      var N = r(3901);
      let T = new P.Logger(E.i),
        O = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
      class A extends I {
        constructor(e, t) {
          let r = new C(e, t),
            n = r.connection.url
              .replace(/^http/i, "ws")
              .replace(".alchemyapi.", ".ws.alchemyapi.");
          super(n, r.network), (0, k.defineReadOnly)(this, "apiKey", r.apiKey);
        }
        isCommunityResource() {
          return this.apiKey === O;
        }
      }
      class C extends N.l {
        static getWebSocketProvider(e, t) {
          return new A(e, t);
        }
        static getApiKey(e) {
          return null == e
            ? O
            : (e &&
                "string" != typeof e &&
                T.throwArgumentError("invalid apiKey", "apiKey", e),
              e);
        }
        static getUrl(e, t) {
          let r = null;
          switch (e.name) {
            case "homestead":
              r = "eth-mainnet.alchemyapi.io/v2/";
              break;
            case "goerli":
              r = "eth-goerli.g.alchemy.com/v2/";
              break;
            case "matic":
              r = "polygon-mainnet.g.alchemy.com/v2/";
              break;
            case "maticmum":
              r = "polygon-mumbai.g.alchemy.com/v2/";
              break;
            case "arbitrum":
              r = "arb-mainnet.g.alchemy.com/v2/";
              break;
            case "arbitrum-goerli":
              r = "arb-goerli.g.alchemy.com/v2/";
              break;
            case "optimism":
              r = "opt-mainnet.g.alchemy.com/v2/";
              break;
            case "optimism-goerli":
              r = "opt-goerli.g.alchemy.com/v2/";
              break;
            default:
              T.throwArgumentError(
                "unsupported network",
                "network",
                arguments[0]
              );
          }
          return {
            allowGzip: !0,
            url: "https://" + r + t,
            throttleCallback: (e, r) => (
              t === O && (0, w.vh)(), Promise.resolve(!0)
            ),
          };
        }
        isCommunityResource() {
          return this.apiKey === O;
        }
      }
      let L = new P.Logger(E.i),
        j = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
      class U extends N.l {
        isCommunityResource() {
          return this.apiKey === j;
        }
        static getApiKey(e) {
          return null == e ? j : e;
        }
        static getUrl(e, t) {
          null == t && (t = j);
          let r = {
            allowGzip: !0,
            url:
              "https://" +
              (function (e) {
                switch (e) {
                  case "homestead":
                    return "rpc.ankr.com/eth/";
                  case "ropsten":
                    return "rpc.ankr.com/eth_ropsten/";
                  case "rinkeby":
                    return "rpc.ankr.com/eth_rinkeby/";
                  case "goerli":
                    return "rpc.ankr.com/eth_goerli/";
                  case "matic":
                    return "rpc.ankr.com/polygon/";
                  case "arbitrum":
                    return "rpc.ankr.com/arbitrum/";
                }
                return L.throwArgumentError("unsupported network", "name", e);
              })(e.name) +
              t,
            throttleCallback: (e, r) => (
              t.apiKey === j && (0, w.vh)(), Promise.resolve(!0)
            ),
          };
          return (
            null != t.projectSecret &&
              ((r.user = ""), (r.password = t.projectSecret)),
            r
          );
        }
      }
      let B = new P.Logger(E.i);
      class K extends N.l {
        static getApiKey(e) {
          return (
            null != e &&
              B.throwArgumentError(
                "apiKey not supported for cloudflare",
                "apiKey",
                e
              ),
            null
          );
        }
        static getUrl(e, t) {
          let r = null;
          return (
            "homestead" === e.name
              ? (r = "https://cloudflare-eth.com/")
              : B.throwArgumentError(
                  "unsupported network",
                  "network",
                  arguments[0]
                ),
            r
          );
        }
        perform(e, t) {
          var r, n, o, i;
          let s = Object.create(null, {
            perform: { get: () => super.perform },
          });
          return (
            (r = this),
            (n = void 0),
            (o = void 0),
            (i = function* () {
              if ("getBlockNumber" === e) {
                let e = yield s.perform.call(this, "getBlock", {
                  blockTag: "latest",
                });
                return e.number;
              }
              return s.perform.call(this, e, t);
            }),
            new (o || (o = Promise))(function (e, t) {
              function s(e) {
                try {
                  c(i.next(e));
                } catch (e) {
                  t(e);
                }
              }
              function a(e) {
                try {
                  c(i.throw(e));
                } catch (e) {
                  t(e);
                }
              }
              function c(t) {
                var r;
                t.done
                  ? e(t.value)
                  : ((r = t.value) instanceof o
                      ? r
                      : new o(function (e) {
                          e(r);
                        })
                    ).then(s, a);
              }
              c((i = i.apply(r, n || [])).next());
            })
          );
        }
      }
      var D = r(6441),
        H = r(3875),
        F = r(7707),
        W = function (e, t, r, n) {
          return new (r || (r = Promise))(function (o, i) {
            function s(e) {
              try {
                c(n.next(e));
              } catch (e) {
                i(e);
              }
            }
            function a(e) {
              try {
                c(n.throw(e));
              } catch (e) {
                i(e);
              }
            }
            function c(e) {
              var t;
              e.done
                ? o(e.value)
                : ((t = e.value) instanceof r
                    ? t
                    : new r(function (e) {
                        e(t);
                      })
                  ).then(s, a);
            }
            c((n = n.apply(e, t || [])).next());
          });
        };
      let J = new P.Logger(E.i);
      function q(e) {
        let t = {};
        for (let r in e) {
          if (null == e[r]) continue;
          let n = e[r];
          ("type" !== r || 0 !== n) &&
            ((n = {
              type: !0,
              gasLimit: !0,
              gasPrice: !0,
              maxFeePerGs: !0,
              maxPriorityFeePerGas: !0,
              nonce: !0,
              value: !0,
            }[r]
              ? (0, D.hexValue)((0, D.hexlify)(n))
              : "accessList" === r
              ? "[" +
                (0, H.accessListify)(n)
                  .map(
                    (e) =>
                      `{address:"${
                        e.address
                      }",storageKeys:["${e.storageKeys.join('","')}"]}`
                  )
                  .join(",") +
                "]"
              : (0, D.hexlify)(n)),
            (t[r] = n));
        }
        return t;
      }
      function M(e) {
        if (
          0 == e.status &&
          ("No records found" === e.message ||
            "No transactions found" === e.message)
        )
          return e.result;
        if (
          1 != e.status ||
          "string" != typeof e.message ||
          !e.message.match(/^OK/)
        ) {
          let t = Error("invalid response");
          throw (
            ((t.result = JSON.stringify(e)),
            (e.result || "").toLowerCase().indexOf("rate limit") >= 0 &&
              (t.throttleRetry = !0),
            t)
          );
        }
        return e.result;
      }
      function V(e) {
        if (
          e &&
          0 == e.status &&
          "NOTOK" == e.message &&
          (e.result || "").toLowerCase().indexOf("rate limit") >= 0
        ) {
          let t = Error("throttled response");
          throw ((t.result = JSON.stringify(e)), (t.throttleRetry = !0), t);
        }
        if ("2.0" != e.jsonrpc) {
          let t = Error("invalid response");
          throw ((t.result = JSON.stringify(e)), t);
        }
        if (e.error) {
          let t = Error(e.error.message || "unknown error");
          throw (
            (e.error.code && (t.code = e.error.code),
            e.error.data && (t.data = e.error.data),
            t)
          );
        }
        return e.result;
      }
      function $(e) {
        if ("pending" === e) throw Error("pending not supported");
        return "latest" === e ? e : parseInt(e.substring(2), 16);
      }
      function G(e, t, r) {
        if ("call" === e && t.code === P.Logger.errors.SERVER_ERROR) {
          let e = t.error;
          if (
            e &&
            (e.message.match(/reverted/i) ||
              e.message.match(/VM execution error/i))
          ) {
            let r = e.data;
            if (
              (r && (r = "0x" + r.replace(/^.*0x/i, "")), (0, D.isHexString)(r))
            )
              return r;
            J.throwError(
              "missing revert data in call exception",
              P.Logger.errors.CALL_EXCEPTION,
              { error: t, data: "0x" }
            );
          }
        }
        let n = t.message;
        throw (
          (t.code === P.Logger.errors.SERVER_ERROR &&
            (t.error && "string" == typeof t.error.message
              ? (n = t.error.message)
              : "string" == typeof t.body
              ? (n = t.body)
              : "string" == typeof t.responseText && (n = t.responseText)),
          (n = (n || "").toLowerCase()).match(/insufficient funds/) &&
            J.throwError(
              "insufficient funds for intrinsic transaction cost",
              P.Logger.errors.INSUFFICIENT_FUNDS,
              { error: t, method: e, transaction: r }
            ),
          n.match(
            /same hash was already imported|transaction nonce is too low|nonce too low/
          ) &&
            J.throwError(
              "nonce has already been used",
              P.Logger.errors.NONCE_EXPIRED,
              { error: t, method: e, transaction: r }
            ),
          n.match(/another transaction with same nonce/) &&
            J.throwError(
              "replacement fee too low",
              P.Logger.errors.REPLACEMENT_UNDERPRICED,
              { error: t, method: e, transaction: r }
            ),
          n.match(/execution failed due to an exception|execution reverted/) &&
            J.throwError(
              "cannot estimate gas; transaction may fail or may require manual gas limit",
              P.Logger.errors.UNPREDICTABLE_GAS_LIMIT,
              { error: t, method: e, transaction: r }
            ),
          t)
        );
      }
      class Z extends b.Zk {
        constructor(e, t) {
          super(e),
            (0, k.defineReadOnly)(this, "baseUrl", this.getBaseUrl()),
            (0, k.defineReadOnly)(this, "apiKey", t || null);
        }
        getBaseUrl() {
          switch (this.network ? this.network.name : "invalid") {
            case "homestead":
              return "https://api.etherscan.io";
            case "goerli":
              return "https://api-goerli.etherscan.io";
            case "sepolia":
              return "https://api-sepolia.etherscan.io";
            case "matic":
              return "https://api.polygonscan.com";
            case "maticmum":
              return "https://api-testnet.polygonscan.com";
            case "arbitrum":
              return "https://api.arbiscan.io";
            case "arbitrum-goerli":
              return "https://api-goerli.arbiscan.io";
            case "optimism":
              return "https://api-optimistic.etherscan.io";
            case "optimism-goerli":
              return "https://api-goerli-optimistic.etherscan.io";
          }
          return J.throwArgumentError(
            "unsupported network",
            "network",
            this.network.name
          );
        }
        getUrl(e, t) {
          let r = Object.keys(t).reduce((e, r) => {
              let n = t[r];
              return null != n && (e += `&${r}=${n}`), e;
            }, ""),
            n = this.apiKey ? `&apikey=${this.apiKey}` : "";
          return `${this.baseUrl}/api?module=${e}${r}${n}`;
        }
        getPostUrl() {
          return `${this.baseUrl}/api`;
        }
        getPostData(e, t) {
          return (t.module = e), (t.apikey = this.apiKey), t;
        }
        fetch(e, t, r) {
          return W(this, void 0, void 0, function* () {
            let n = r ? this.getPostUrl() : this.getUrl(e, t),
              o = r ? this.getPostData(e, t) : null;
            this.emit("debug", {
              action: "request",
              request: n,
              provider: this,
            });
            let i = {
                url: n,
                throttleSlotInterval: 1e3,
                throttleCallback: (e, t) => (
                  this.isCommunityResource() && (0, w.vh)(), Promise.resolve(!0)
                ),
              },
              s = null;
            o &&
              ((i.headers = {
                "content-type":
                  "application/x-www-form-urlencoded; charset=UTF-8",
              }),
              (s = Object.keys(o)
                .map((e) => `${e}=${o[e]}`)
                .join("&")));
            let a = yield (0, F.fetchJson)(i, s, ("proxy" === e ? V : M) || V);
            return (
              this.emit("debug", {
                action: "response",
                request: n,
                response: (0, k.deepCopy)(a),
                provider: this,
              }),
              a
            );
          });
        }
        detectNetwork() {
          return W(this, void 0, void 0, function* () {
            return this.network;
          });
        }
        perform(e, t) {
          let r = Object.create(null, {
            perform: { get: () => super.perform },
          });
          return W(this, void 0, void 0, function* () {
            switch (e) {
              case "getBlockNumber":
                return this.fetch("proxy", { action: "eth_blockNumber" });
              case "getGasPrice":
                return this.fetch("proxy", { action: "eth_gasPrice" });
              case "getBalance":
                return this.fetch("account", {
                  action: "balance",
                  address: t.address,
                  tag: t.blockTag,
                });
              case "getTransactionCount":
                return this.fetch("proxy", {
                  action: "eth_getTransactionCount",
                  address: t.address,
                  tag: t.blockTag,
                });
              case "getCode":
                return this.fetch("proxy", {
                  action: "eth_getCode",
                  address: t.address,
                  tag: t.blockTag,
                });
              case "getStorageAt":
                return this.fetch("proxy", {
                  action: "eth_getStorageAt",
                  address: t.address,
                  position: t.position,
                  tag: t.blockTag,
                });
              case "sendTransaction":
                return this.fetch(
                  "proxy",
                  {
                    action: "eth_sendRawTransaction",
                    hex: t.signedTransaction,
                  },
                  !0
                ).catch((e) => G("sendTransaction", e, t.signedTransaction));
              case "getBlock":
                if (t.blockTag)
                  return this.fetch("proxy", {
                    action: "eth_getBlockByNumber",
                    tag: t.blockTag,
                    boolean: t.includeTransactions ? "true" : "false",
                  });
                throw Error("getBlock by blockHash not implemented");
              case "getTransaction":
                return this.fetch("proxy", {
                  action: "eth_getTransactionByHash",
                  txhash: t.transactionHash,
                });
              case "getTransactionReceipt":
                return this.fetch("proxy", {
                  action: "eth_getTransactionReceipt",
                  txhash: t.transactionHash,
                });
              case "call": {
                if ("latest" !== t.blockTag)
                  throw Error(
                    "EtherscanProvider does not support blockTag for call"
                  );
                let e = q(t.transaction);
                (e.module = "proxy"), (e.action = "eth_call");
                try {
                  return yield this.fetch("proxy", e, !0);
                } catch (e) {
                  return G("call", e, t.transaction);
                }
              }
              case "estimateGas": {
                let e = q(t.transaction);
                (e.module = "proxy"), (e.action = "eth_estimateGas");
                try {
                  return yield this.fetch("proxy", e, !0);
                } catch (e) {
                  return G("estimateGas", e, t.transaction);
                }
              }
              case "getLogs": {
                let e = { action: "getLogs" };
                if (
                  (t.filter.fromBlock && (e.fromBlock = $(t.filter.fromBlock)),
                  t.filter.toBlock && (e.toBlock = $(t.filter.toBlock)),
                  t.filter.address && (e.address = t.filter.address),
                  t.filter.topics &&
                    t.filter.topics.length > 0 &&
                    (t.filter.topics.length > 1 &&
                      J.throwError(
                        "unsupported topic count",
                        P.Logger.errors.UNSUPPORTED_OPERATION,
                        { topics: t.filter.topics }
                      ),
                    1 === t.filter.topics.length))
                ) {
                  let r = t.filter.topics[0];
                  ("string" != typeof r || 66 !== r.length) &&
                    J.throwError(
                      "unsupported topic format",
                      P.Logger.errors.UNSUPPORTED_OPERATION,
                      { topic0: r }
                    ),
                    (e.topic0 = r);
                }
                let r = yield this.fetch("logs", e),
                  n = {};
                for (let e = 0; e < r.length; e++) {
                  let t = r[e];
                  if (null == t.blockHash) {
                    if (null == n[t.blockNumber]) {
                      let e = yield this.getBlock(t.blockNumber);
                      e && (n[t.blockNumber] = e.hash);
                    }
                    t.blockHash = n[t.blockNumber];
                  }
                }
                return r;
              }
              case "getEtherPrice":
                if ("homestead" !== this.network.name) return 0;
                return parseFloat(
                  (yield this.fetch("stats", { action: "ethprice" })).ethusd
                );
            }
            return r.perform.call(this, e, t);
          });
        }
        getHistory(e, t, r) {
          return W(this, void 0, void 0, function* () {
            let n = {
                action: "txlist",
                address: yield this.resolveName(e),
                startblock: null == t ? 0 : t,
                endblock: null == r ? 99999999 : r,
                sort: "asc",
              },
              o = yield this.fetch("account", n);
            return o.map((e) => {
              ["contractAddress", "to"].forEach(function (t) {
                "" == e[t] && delete e[t];
              }),
                null == e.creates &&
                  null != e.contractAddress &&
                  (e.creates = e.contractAddress);
              let t = this.formatter.transactionResponse(e);
              return e.timeStamp && (t.timestamp = parseInt(e.timeStamp)), t;
            });
          });
        }
        isCommunityResource() {
          return null == this.apiKey;
        }
      }
      var z = r(1619);
      let Q = null,
        X = new P.Logger(E.i),
        Y = "84842078b09946638c03157f83405213";
      class ee extends I {
        constructor(e, t) {
          let r = new et(e, t),
            n = r.connection;
          n.password &&
            X.throwError(
              "INFURA WebSocket project secrets unsupported",
              P.Logger.errors.UNSUPPORTED_OPERATION,
              { operation: "InfuraProvider.getWebSocketProvider()" }
            );
          let o = n.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
          super(o, e),
            (0, k.defineReadOnly)(this, "apiKey", r.projectId),
            (0, k.defineReadOnly)(this, "projectId", r.projectId),
            (0, k.defineReadOnly)(this, "projectSecret", r.projectSecret);
        }
        isCommunityResource() {
          return this.projectId === Y;
        }
      }
      class et extends N.l {
        static getWebSocketProvider(e, t) {
          return new ee(e, t);
        }
        static getApiKey(e) {
          let t = { apiKey: Y, projectId: Y, projectSecret: null };
          return (
            null == e ||
              ("string" == typeof e
                ? (t.projectId = e)
                : null != e.projectSecret
                ? (X.assertArgument(
                    "string" == typeof e.projectId,
                    "projectSecret requires a projectId",
                    "projectId",
                    e.projectId
                  ),
                  X.assertArgument(
                    "string" == typeof e.projectSecret,
                    "invalid projectSecret",
                    "projectSecret",
                    "[REDACTED]"
                  ),
                  (t.projectId = e.projectId),
                  (t.projectSecret = e.projectSecret))
                : e.projectId && (t.projectId = e.projectId),
              (t.apiKey = t.projectId)),
            t
          );
        }
        static getUrl(e, t) {
          let r = null;
          switch (e ? e.name : "unknown") {
            case "homestead":
              r = "mainnet.infura.io";
              break;
            case "goerli":
              r = "goerli.infura.io";
              break;
            case "sepolia":
              r = "sepolia.infura.io";
              break;
            case "matic":
              r = "polygon-mainnet.infura.io";
              break;
            case "maticmum":
              r = "polygon-mumbai.infura.io";
              break;
            case "optimism":
              r = "optimism-mainnet.infura.io";
              break;
            case "optimism-goerli":
              r = "optimism-goerli.infura.io";
              break;
            case "arbitrum":
              r = "arbitrum-mainnet.infura.io";
              break;
            case "arbitrum-goerli":
              r = "arbitrum-goerli.infura.io";
              break;
            default:
              X.throwError(
                "unsupported network",
                P.Logger.errors.INVALID_ARGUMENT,
                { argument: "network", value: e }
              );
          }
          let n = {
            allowGzip: !0,
            url: "https://" + r + "/v3/" + t.projectId,
            throttleCallback: (e, r) => (
              t.projectId === Y && (0, w.vh)(), Promise.resolve(!0)
            ),
          };
          return (
            null != t.projectSecret &&
              ((n.user = ""), (n.password = t.projectSecret)),
            n
          );
        }
        isCommunityResource() {
          return this.projectId === Y;
        }
      }
      class er extends v.r {
        send(e, t) {
          let r = { method: e, params: t, id: this._nextId++, jsonrpc: "2.0" };
          null == this._pendingBatch && (this._pendingBatch = []);
          let n = { request: r, resolve: null, reject: null },
            o = new Promise((e, t) => {
              (n.resolve = e), (n.reject = t);
            });
          return (
            this._pendingBatch.push(n),
            this._pendingBatchAggregator ||
              (this._pendingBatchAggregator = setTimeout(() => {
                let e = this._pendingBatch;
                (this._pendingBatch = null),
                  (this._pendingBatchAggregator = null);
                let t = e.map((e) => e.request);
                return (
                  this.emit("debug", {
                    action: "requestBatch",
                    request: (0, k.deepCopy)(t),
                    provider: this,
                  }),
                  (0, F.fetchJson)(this.connection, JSON.stringify(t)).then(
                    (r) => {
                      this.emit("debug", {
                        action: "response",
                        request: t,
                        response: r,
                        provider: this,
                      }),
                        e.forEach((e, t) => {
                          let n = r[t];
                          if (n.error) {
                            let t = Error(n.error.message);
                            (t.code = n.error.code),
                              (t.data = n.error.data),
                              e.reject(t);
                          } else e.resolve(n.result);
                        });
                    },
                    (r) => {
                      this.emit("debug", {
                        action: "response",
                        error: r,
                        request: t,
                        provider: this,
                      }),
                        e.forEach((e) => {
                          e.reject(r);
                        });
                    }
                  )
                );
              }, 10)),
            o
          );
        }
      }
      let en = new P.Logger(E.i);
      class eo extends N.l {
        static getApiKey(e) {
          return (
            e &&
              "string" != typeof e &&
              en.throwArgumentError("invalid apiKey", "apiKey", e),
            e || "ETHERS_JS_SHARED"
          );
        }
        static getUrl(e, t) {
          en.warn(
            "NodeSmith will be discontinued on 2019-12-20; please migrate to another platform."
          );
          let r = null;
          switch (e.name) {
            case "homestead":
              r = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
              break;
            case "ropsten":
              r = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
              break;
            case "rinkeby":
              r = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
              break;
            case "goerli":
              r = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
              break;
            case "kovan":
              r = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
              break;
            default:
              en.throwArgumentError(
                "unsupported network",
                "network",
                arguments[0]
              );
          }
          return r + "?apiKey=" + t;
        }
      }
      let ei = new P.Logger(E.i),
        es = "62e1ad51b37b8e00394bda3b";
      class ea extends N.l {
        static getApiKey(e) {
          let t = {
            applicationId: null,
            loadBalancer: !0,
            applicationSecretKey: null,
          };
          return (
            null == e
              ? (t.applicationId = es)
              : "string" == typeof e
              ? (t.applicationId = e)
              : null != e.applicationSecretKey
              ? ((t.applicationId = e.applicationId),
                (t.applicationSecretKey = e.applicationSecretKey))
              : e.applicationId
              ? (t.applicationId = e.applicationId)
              : ei.throwArgumentError(
                  "unsupported PocketProvider apiKey",
                  "apiKey",
                  e
                ),
            t
          );
        }
        static getUrl(e, t) {
          let r = null;
          switch (e ? e.name : "unknown") {
            case "goerli":
              r = "eth-goerli.gateway.pokt.network";
              break;
            case "homestead":
              r = "eth-mainnet.gateway.pokt.network";
              break;
            case "kovan":
              r = "poa-kovan.gateway.pokt.network";
              break;
            case "matic":
              r = "poly-mainnet.gateway.pokt.network";
              break;
            case "maticmum":
              r = "polygon-mumbai-rpc.gateway.pokt.network";
              break;
            case "rinkeby":
              r = "eth-rinkeby.gateway.pokt.network";
              break;
            case "ropsten":
              r = "eth-ropsten.gateway.pokt.network";
              break;
            default:
              ei.throwError(
                "unsupported network",
                P.Logger.errors.INVALID_ARGUMENT,
                { argument: "network", value: e }
              );
          }
          let n = `https://${r}/v1/lb/${t.applicationId}`,
            o = { headers: {}, url: n };
          return (
            null != t.applicationSecretKey &&
              ((o.user = ""), (o.password = t.applicationSecretKey)),
            o
          );
        }
        isCommunityResource() {
          return this.applicationId === es;
        }
      }
      var ec = r(241);
      let eu = new P.Logger(E.i);
      function el(e, t) {
        if ((null == e && (e = "homestead"), "string" == typeof e)) {
          let t = e.match(/^(ws|http)s?:/i);
          if (t)
            switch (t[1].toLowerCase()) {
              case "http":
              case "https":
                return new v.r(e);
              case "ws":
              case "wss":
                return new I(e);
              default:
                eu.throwArgumentError("unsupported URL scheme", "network", e);
            }
        }
        let r = (0, y.H)(e);
        return (
          (r && r._defaultProvider) ||
            eu.throwError(
              "unsupported getDefaultProvider network",
              P.Logger.errors.NETWORK_ERROR,
              { operation: "getDefaultProvider", network: e }
            ),
          r._defaultProvider(
            {
              FallbackProvider: z.H,
              AlchemyProvider: C,
              AnkrProvider: U,
              CloudflareProvider: K,
              EtherscanProvider: Z,
              InfuraProvider: et,
              JsonRpcProvider: v.r,
              NodesmithProvider: eo,
              PocketProvider: ea,
              Web3Provider: ec.Q,
              IpcProvider: Q,
            },
            t
          )
        );
      }
      var ep = r(234),
        ed = r(8812),
        eh = r(4243),
        ef = r(1388),
        eg = r(1184),
        em = r(8198),
        ey = r(9485),
        eb = r(4089),
        ek = r(7727),
        ew = r(7586),
        ev = r(3684),
        eP = r(2046),
        eE = r(7827),
        eS = r(4178),
        e_ = r(7949),
        eR = r(8197),
        ex = r(2006),
        eI = r(1886),
        eN = r(5634),
        eT = r(2472),
        eO = r(9052),
        eA = r(7669),
        eC = r(5637),
        eL = r(9251),
        ej = r(6237),
        eU = r(1744),
        eB = r(1261);
      let eK = "ethers/5.7.2",
        eD = new P.Logger(eK);
      try {
        let e = window;
        null == e._ethers && (e._ethers = s);
      } catch (e) {}
    },
    1163: function (e, t, r) {
      e.exports = r(6885);
    },
  },
]);
